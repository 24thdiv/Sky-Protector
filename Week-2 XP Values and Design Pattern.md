## 1. Darshil Saraiya

* **Design Pattern**

    * State
  
    * Observer
    
    * Composite
    
* **XP Value**   
  
    * Simplicity   

* **Journal Entry**

    In the second week of implementing the project, we started to refine the important requirements.The team has given constant efforts in making the flow of game as simple as possible to reduce the operating cost because the simple solutions are cheaper and quicker to implement.
    
    I helped the team to understand that implementing the design pattern is not the only solution to our project, but the Simplicity is also the part of the efficient solution. While implementing the functionality of health bar of rocket ship and enemy ship, the team confronted the complexity of code. We agreed on removing the inefficient and complex code and replacing it with much simpler code. I conveyed to the team about creating simple class architecture because if a single class breaks, the whole system may break.
    
    I emphasized the point of simplicity while implementing any functionality because the simplest solution are always the robust solutions and make our system less prone to breaking. We also had issue raised to make the code as simple as possible to implement with better efficiency and everyone gave their ideas so that we can apply during implementation.
    
## 2. Divyakumar Patel

* **Design Pattern**

    * State
  
    * Observer
    
    * Command
    
* **XP Value**   
  
    * Courage
    
* **Journal Entry**

      In past week, while choosing project and deciding its requirements, I encouraged my team members to scale the requirements which were most important. It takes courage to change the requirements with continuous feedback and openness as well as direct communication with all the team members.
      
      When we were generating firing weapons functionality, the code got staggeringly complex. Few of my team members got scared. They feared about the next requirement becoming inconceivable. I inspired them to focus on implementation of current requirement rather than worrying about the next on. For some functionalities in the project, the team thought that the project is destined to fail- resulting in a "Death March Project", but I encouraged them to tell the truth in communication, which ensued in increased enthusiasm.
      
      In team meeting, one of my team members pointed out complexity as well as redundancy in code. So, I advocated to discard the same code. We also came on conclusion to get rid of ineffective solutions even if we have invested too much time on them.
      
## 3. Anuvrat Tiku

* **Design Pattern**

    * State
  
    * Factory
    
    * Decorator
    
* **XP Value**   
  
    * Limiting Work in Progress
    
* **Journal Entry**

      We are in the second week of the project development. In the beginning of this week, all the team members had the basic idea of what was expected to be delivered. So we divided the task among us in terms of what components need to be coded by whom. We have a team of six members. So it was important to establish a basic ground rule to begin with concerning limiting work in progress : Not more than 6 tasks can ever be "In Progress"at any time. This maps 1 in progress task to each member. We wan to avoid parallelization of tasks. What I wanted was my team to focus on only one task at a time.This avoids any unnecessary lags or bottlenecks. Having more than one task leads to unnecessary task-switching and confusion. All team members can only proceed to a new task once they have closed one task. A scenario that occurred was: I was supposed to work on basic home screen in this second week but I was unable to finish it. So I decided to start working on another task to get some progress. So I decided to push the Home screen coding back to the product backlog and start working on the new task because we are not supposed to work on more than one item at one time. This is how I implemented the Kanban value of Limiting the Work in Progress in our project.  

